name: Deploy DEV (BlueGreen)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: eu-north-1

      # === ECR ===
      # В твоём AWS ECR существует: ecs-platform-dev-backend и ecs-platform-dev-api
      ECR_REPO: ecs-platform-dev-backend
      IMAGE_TAG: ${{ github.sha }}

      # === ECS ===
      CONTAINER_NAME: app
      TASKDEF_TEMPLATE: taskdef.json

      # === CodeDeploy (Blue/Green) ===
      CODEDEPLOY_APP: ecs-platform-dev-cd-app
      CODEDEPLOY_DG: ecs-platform-dev-cd-dg

      # === AppSpec ===
      APPSPEC_FILE: appspec.yaml
      # если хочешь dev-файл:
      # APPSPEC_FILE: appspec-dev.yaml

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::636851749897:role/ecs-platform-dev-github-actions
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        run: |
          set -e
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}"
          IMAGE="${ECR_URI}:${IMAGE_TAG}"

          echo "ECR_URI=$ECR_URI" >> $GITHUB_ENV
          echo "IMAGE=$IMAGE" >> $GITHUB_ENV

          docker build -t "$IMAGE" -f app/Dockerfile ./app
          docker push "$IMAGE"

      - name: Prepare new task definition (clean + set image)
        run: |
          set -e

          # 1) привести taskdef к формату register-task-definition + удалить null
          jq '{
            family: .family,
            taskRoleArn: .taskRoleArn,
            executionRoleArn: .executionRoleArn,
            networkMode: .networkMode,
            containerDefinitions: .containerDefinitions,
            volumes: .volumes,
            placementConstraints: .placementConstraints,
            requiresCompatibilities: .requiresCompatibilities,
            cpu: .cpu,
            memory: .memory,
            pidMode: .pidMode,
            ipcMode: .ipcMode,
            proxyConfiguration: .proxyConfiguration,
            inferenceAccelerators: .inferenceAccelerators,
            ephemeralStorage: .ephemeralStorage,
            runtimePlatform: .runtimePlatform
          } | with_entries(select(.value != null))' "$TASKDEF_TEMPLATE" > taskdef.clean.json

          # 2) подставить новый image в контейнер app
          jq --arg IMAGE "$IMAGE" --arg NAME "$CONTAINER_NAME" '
            .containerDefinitions |=
              (map(if .name == $NAME then .image = $IMAGE else . end))
          ' taskdef.clean.json > taskdef.new.json

          echo "taskdef.new.json (first lines):"
          cat taskdef.new.json | head -n 60

      - name: Register new task definition
        run: |
          set -e
          ARN=$(aws ecs register-task-definition \
            --cli-input-json file://taskdef.new.json \
            --region "$AWS_REGION" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "TASK_DEF_ARN=$ARN" >> $GITHUB_ENV
          echo "Registered task definition: $ARN"

      - name: BlueGreen deploy (CodeDeploy)
        run: |
          set -e

          # IMPORTANT FIX:
          # When using revisionType=AppSpecContent, CodeDeploy needs TaskDefinition ARN in AppSpec,
          # not "taskdef.json" file reference.
          sed "s|TaskDefinition:.*|TaskDefinition: ${TASK_DEF_ARN}|g" "$APPSPEC_FILE" > appspec.rendered.yaml

          echo "Rendered appspec:"
          head -n 30 appspec.rendered.yaml

          # Build revision.json with raw YAML content (no base64)
          jq -n --rawfile appspec appspec.rendered.yaml \
            '{revisionType:"AppSpecContent", appSpecContent:{content:$appspec}}' > revision.json

          echo "Creating CodeDeploy deployment..."
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name "$CODEDEPLOY_APP" \
            --deployment-group-name "$CODEDEPLOY_DG" \
            --revision file://revision.json \
            --region "$AWS_REGION" \
            --query "deploymentId" \
            --output text)

          echo "DEPLOYMENT_ID=$DEPLOYMENT_ID"

          # Wait for real result so workflow is truly green
          aws deploy wait deployment-successful --deployment-id "$DEPLOYMENT_ID"

